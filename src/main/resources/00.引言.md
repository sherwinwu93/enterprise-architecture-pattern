### 引言
构建计算机系统并非易事.随着系统复杂性的增大,构建相应软件的难度将呈指数级增大.同其他行业一样,
我们只有在不断的学习中进步,从成功经验中学习,从失败教训中学习,才有望克服这些困难.本书中的内
容就是这样一些"学习"经验.我希望它们的攥写和编排方式,能够有助于读者更快地学习这些内容,并且,
和我在总结出这些模式之前相比,能更有效地与他人进行交流.

在引言中,我向设定本书讨论的范围,并提供一些相关的背景知识与材料.

#### 0.1 架构

软件业的人乐于做这些的事--找一些词汇,并把它们引申到大量微妙而又互相矛盾的含义.一个最大的受
害者就是"架构"这个词.我个人对"架构"的感觉是,它是一个让人印象深刻的词,主要用来表示一些非常
重要的东西.当然,我也会小心,不让这些对"系统结构"的"不恭之词",影响到读者对本书的兴趣.

很多人都试图给"架构"下定义,而这些定义本身却很难统一.能够统一的内容有两点:一点是"最高层次的
系统分解";另一点是"系统中不易改变的决定".越来越多的人发现:表述一个系统架构的方法不止一种:
一个系统中也可能有很多种不同的架构.而且,对于什么在架构上意义重大的看法也会随着系统的生命周
期变化.

Ralph Johnson,发表了一些关于"架构"的观点.他认为,架构是一种主观的东西,是专家级项目开发人员
对系统设计的一些可共享的理解.一般地,这种可共享的理解表现为系统中主要的组成部分以及这些组成
间的交互关系.它还包括一些决定,开发者们希望这些决定能及早做出,因为在开发者看来它们是难以改变
的.架构的主观性也来源于此--如果你发现某些决定并不像你想象得那么难以改变,那么它就不再与架构
相关.到了最后,架构自然就浓缩成一些重要得东西,不论这些东西是什么.

在本书中,涉及企业应用主要组成部分和我希望能尽早做出的决定.在这些架构模式中,我最欣赏的就是"
层次",将在第1章进行详细介绍.全书实际上就是关于如何将企业应用组织成不同的层次,以及这些层次
之间如何协同工作.大多数重要的企业应用都是按照某种形式的层次分层设计的.当然,在某些情况下,别
的设计方式(如管道方式、过滤器方式等)也有它们自己的价值.我们将不讨论这些方式,而把注意力集中
在层次方式上,因为它是应用最广的设计方式.

本书中的一些模式是关于架构的,它们表示了企业应用各主要组成部分间的重要决定;另外一些模式是关
于设计的,有助于架构的实现.我没有刻意区分这两类模式,因为正如我们前面讨论的,是否与架构相关往
往带有主观性.

#### 0.2 企业应用
软件的种类是不同的,每种软件都有自身的挑战性和复杂性.企业应用在某些方面要比电信软件简单得多
--多线程问题没有那么困难,无需关注硬件设备与软件的集成.但是,某些方面,企业应用又被电信软件复
杂得多--企业应用一般都涉及大量复杂数据,而且必须处理很多"不合逻辑"的业务规则.虽然有些模式是
最适合于所有软件的,但是大多数模式都还只适合某些特定的领域和分支.

企业应用具体指的是什么呢?

先举几个例子.企业应用包括工资单,患者记录,发货跟踪,成本分析,信誉评估,保险,供应链,记账,客户
服务以及外币交易等.企业应用不包括车辆加油,文字处理,电梯控制,化工厂控制器,电话交换机,操作系
统,编译器以及电子游戏等.

企业应用一般都涉及持久化数据.数据必须持久化是因为程序的多次运行都需要用到它们--实际上,有些
数据需要持久化若干年.在此期间,操作这些数据的程序往往会有很多变化.这些数据的生命周期往往比
最初生成它们的那些硬件,操作系统和编译器还要长.在此期间,数据本身的结构一般也会被拓展,使得它
在不影响已有信息的基础上,还能表示更多新信息.即使是有根本性的变化发生,或公司安装了一套全新
的软件,这些数据也必须被"迁移"到这些全新的应用上.

企业应用一般都涉及大量数据--一个中等规模的系统往往包含1GB一上的数据.这些数据是以百万条记录
的方式存在的.巨大的数据量导致数据的管理成为系统的主要工作.早期的系统使用的是索引文件系统,
如IBM的VSAM和ISAM.现代的系统往往采用数据库,绝大多数是关系型数据库.数据库的设计和演化已使
其本身成为新的技术领域.

企业应用一般还涉及很多人同时访问数据.对于很多系统来说,人数可能在100人以下,但是对于一些基
于Web的系统,人数则会呈指数级增长.要确保这些人都能够正确地访问数据,就一定会存在这些或那样
的问题.即使人数没有那么多,要确保两个人在同时操作同一数据项时不出现错误,也是存在问题的.事
务管理工具可以处理这个问题,但是它通常无法做到对应用开发者透明.

企业应用还涉及大量操作数据的用户界面屏幕.有几百个用户界面屏幕是不足为奇的.用户使用频率的
差异很大,他们也经常没什么技术背景.因此,为了不同的使用目的,数据需要很多种表现形式.系统一般
都有很大批处理过程,当专注于强调用户交互的用例时,这些批处理过程很容易被忽视.

企业应用通常需要与散布在企业周围的其他企业应用集成.各式各样的系统是不同时期,采用不同技术
构建的,甚至连协作机制都不同.当商业用户需要同业务伙伴应用集成时,情况就更糟糕.

即使统一了集成技术.还是会遇到业务过程中的差异以及数据中概念的不一致性.一旦几百个记录中的
每个字段都可能存在着细微差别,问题的规模也会形成不小的挑战--就算唯一知道这些字段之间的员
工还在公司任职.这样,数据就必须被不停地读取,合并,然后写成各种不同语法和语义的格式.

再接下来的问题是由"业务逻辑"带来的."业务逻辑"没有逻辑.当我们构建一个操作系统,总是尽可能
地使得系统中得各种事物符合逻辑.业务逻辑却总有各种各样得理由,需要特殊化定制.成千上万的这类
"一次性特殊情况"最终导致了复杂的业务"无逻辑"使得商业软件开发那么困难.再这种情况下,必须尽
量将这些业务逻辑组织成有效的方式,因为我们可以确定,这些逻辑一定会随着时间不断变化.

并不是所有企业应用都是大型的.因为小型项目的失败相对于大型项目毫不起眼,所以最好是通过简化
架构和过程,将一个大型项目简化成小型项目.

#### 03.企业应用的种类
我们如何涉及企业应用以及使用哪些模式之前,需要明确--即企业应用是多种多样的,不同的问题将导
致不同的处理方法.设计中最具有挑战性的地方就是了解有哪些候选的设计方法以及各种不同设计方法
之间的优劣比较.进行选择的空间很大,但我只选三个方面.

考虑一个B2C:人们通过浏览器浏览,购物车购物.这样的系统必须应付大量的客户.因此,其解决方案不
但要考虑到资源利用的有效性,还要考虑系统的可伸缩性,以便用户规模增大时能够通过增加硬件加以
解决.该系统的业务逻辑可以非常简单:获取订单,进行简单的价格计算和发货计算,给出发货信息.希望
任何人都能够访问该系统,因此用户界面可以选用通用的Web表现方式.以支持不同的浏览器.数据源包
括用来存放订单的数据库.还可能包括某种与库存系统的通信交流,以便获得商品的可用性信息和发货
信息.

再考虑一个租约合同自动处理系统.在某些方面,这样的系统比起前面介绍的B2C系统要简单,因为它的
用户数很少(在特定时间内不会超过100个),但是它的业务逻辑却比较复杂.计算每个租约的月供,处理
如提早解约和延迟付款这样的事件,签订合同时验证各种数据.这些都是非常复杂的任务,因为租约领域
许多竞争都是以过去的交易为基础稍加变化而出现的.正是因为规则的随意性很大,才使得像这样一个
复杂的业务领域具有挑战性.

这样的系统在用户界面(UI)上也很复杂.这就要求HTML界面要能够提供更丰富的功能和更复杂的屏幕.
而这些要求往往时HTML界面目前无法达到的,需要更常规的胖客户界面.用户交互的复杂性还会带来事
务行为的复杂性:签订租约可能要耗时1-2个小时,这期间用户要处于一个逻辑事务中.一个复杂的数据
库设计方案中可能也会涉及200多个表以及一些有关资产评估和计价的软件包.

第三个例子是一家小型公司使用的简单的"开支跟踪系统".这个系统的用户很少,功能简单,通过HTML
表现方式可以很容易实现,涉及的数据源表项也不多.尽管如此,开发这样的系统也不是没有挑战.一方
面你必须快速地开发出它,另一方面你又必须为它以后可能的发展考虑:也许以后会为它增加赔偿校验
的功能,也许它会被集成到工资系统中.也许还要增加关于税务的功能,也许要为公司的CFO生成汇总报
表.也许会被集成到一个航空订票Web Service中,等等.如果在这个系统的开发中,也试图使用前面两
个例子中的一些架构,可能会影响开发进度.如果一个系统会带来业务收益(如所有的企业应用应该的
那样),则系统进度延误同样也是开销.如果现在不做决策又有可能影响到系统的发展,进一步延误系统
部署,减少系统的效益.虽然这类系统很小,但是一个企业中往往有很多这样的系统,这些系统的架构不
良性积累起来,后果会非常可怕.

这三个企业应用都有难点,难点各不相同.当然也不可能有适合于三者的通用架构.选择架构时,必须很
清楚地了解面临的问题,在理解的基础上再来选择合适的设计.实际上,很多模式仅仅时一些可选方案
罢了.即使你选择了某种模式,也需要进一步根据面临的问题来修改模式.在构建企业应用时,你不思考
是不行的.所有书本知识只是给你提供信息,作为你做决定的基础.

模式是这样,工具也同样如此.在系统开发时应该选取尽可能少的工具,同时也要注意,不同的工具擅
长处理的方面也不同.切记不要用错了工具,否则只会事倍功半.

#### 04. 关于性能的考虑
很多架构的设计决策和性能有关.对于大多数与性能有关的问题.首先建立系统,调试运行,然后通过基
于测量的严格的优化过程来提高性能.但是,有一些架构上的决策对性能的影响,可能是后期优化难以
弥补的.而且即使这种影响可以在后期很容易地弥补,参与这个项目的人们仍然会从一开始就担心这些
决策.

所有那些关于性能的条条框框,不在你的具体系统中配置运行一下,是难以有说服力的.一些设计方案因
为性能方面的考虑而被接受或拒绝,但是一旦有人在真实的设置环境做一些测量,就会证明这些考虑是
错误的.

本书也提出一些这方面建议,包括尽量减少远程调用.尽管如此,还是建议读者在运用这些原则,在你的
应用中具体试一试.同样,也有一些地方为了提高可读性而牺牲了效率.在你的系统中,需要自行决定是
否进行优化.做性能优化后,一定要与优化前进行测量对比,以确定真的得到了优化,否则,你可能只是
破坏了代码的可读性.

还有一个很重要的推论:配置上的重大变化会使得某些性能优化失效.因此,在升级虚拟机、硬件、数
据库或其他东西到新的版本时,必须重新确认性能哟话工作的有效性.很多情况下,配置变更都会对性能
优化有影响,有时候你会真的发现,以前为了提升性能所做的优化,在新环境下居然影响性能.

关于性能的另一个问题是很多术语的使用不一致.最明显的例子就是"可伸缩性",它可能有6-7种含义.
下面我使用其中一些术语.

相应时间 是系统完成一次外部请求处理所需的时间.这些外部请求可能是用户交互行为,例如按下一个
按钮,或是服务器API的调用.

响应性 不同于请求处理,它是系统响应请求的速度有多快.这个指标在许多系统里非常重要,因为对于一
些系统而言,如果其响应性太慢,用户难以忍受--尽管其响应时间可能不慢.如果在请求处理期间,系统
一直处在等待状态,则系统的响应性和响应时间是相同的.然而,如果能够在处理真正完成之前就给用户
一些信息表面系统已经接到请求,则响应性就会好一些.例如,在文件拷贝过程中,为用户提供一个"进展
条",将会提高用户界面的响应性,但并不会提高响应时间.

等待时间 是获得系统任何形式响应的最小时间,即使应该做的工作并不存在.通常它是远程系统中的大
问题.假设我们让程序什么都不做,只是调用返回即可,则如果在本机上运行程序,一般都会立即得到响
应,因为从发出请求到得到响应的数秒时间主要用于排除困难使信息在线路上传输.作为应用开发者,我
经常对等待时间无能为力.这也是为什么要尽量避免远程调用的原因.

吞吐率 是给定时间内能够处理多大的请求量.如果考察的是文件拷贝,则吞吐率可以用秒字节量来表示.
对于企业应用来说,吞吐率通常用每秒事务数(tps)来度量.这种方法的一个问题是指标依赖于事务的
复杂程度.对于特定系统的测试,应该选取普通的事务集合.

在这里,性能或者指吞吐率,或者指响应时间,由用户自己决定.当通过某种优化技术后,使得系统的吞吐
率提高了,但是响应时间下降了,这时就不好说系统的性能提高了,最好用更准确的术语表示.从用户角
度而言,响应性往往比响应时间更重要.因此,为了提高响应性而损失一些响应时间或者吞吐率是值得的.

负载 是关于系统当前负荷的表述,也许可以用当前有多少用户与系统相连来表示.负载有时也作为其他
指标(如响应时间)的背景.因此,我们可以说:在10个用户的情况下,请求响应时间是0.5秒,在20个用户
的情况下,请求响应时间是2秒.

负载敏感度 是指响应时间随负载变化的程度.假设: 系统A在10~20个用户的情况下,请求响应时间都
是0.5秒,系统B在10个用户的情况下,请求响应时间是0.2秒,在20个用户的情况下,请求响应时间上升
到2秒.此时,系统A的负载敏感度比系统B低,我们还可以使用术语衰减,称系统B衰减得比系统A快.

效率 是性能除以资源.如果一个双CPU系统的性能是30tps,另一个系统有4个同样的CPU,性能是40tps,
则前者效率高于后者.

系统的容量 是指最大有效负载或吞吐率的指标.它可以是一个绝对最大值或性能衰减至低于一个可接
受的阈值之前的临界点.

可伸缩性度量 是向系统中增加资源(通常是硬件)对系统性能的影响.一个可伸缩的系统允许在增加了
硬件后,能够有性能上的合理提高.例如,为了使吞吐率提高一倍,要增加多少服务器等.垂直可伸缩性
或称垂直延展,通常指提高单个服务器的性能,例如增加内存.水平可伸缩性或水平延展,通常指增加服
务器数目.

问题是,设计决策对所有性能指标的作用并不相同.比如,在某个服务器上运行着两个软件系统:Sword-
fish的容量是20tps,而Gamel的容量是40tps.哪一个性能更高?哪一个的可伸缩性好?仅凭这些数据,
我么无法回答关于可伸缩性的问题,我们只能说Camel系统在单机上的效率更高.

当构建企业应用系统时,关注硬件的可伸缩性往往比关注容量或效率更重要.如果需要,可伸缩性可以
给予你获得更好性能的选择,可伸缩性也可以更容易实现.有时,设计人员费了九牛二虎之力才提高了
少许容量,其开销还不如多买一些硬件.换句话说,假设Camel的费用比Swordfish高,高出的部分正好
可以买几台服务器,那么选择Swordfish可能更合算,尽管你目前只需要40tps.但是总的来说,购买新
硬件还是比修改就软件来得便宜.同样,增加更多的服务器也比增加更多的程序员来得便宜--只要你的
系统有足够的可伸缩性.

#### 0.5 模式
简单谈谈我对模式和它们为什么是描述设计的重要手段的一些看法.

模式没有统一定义,可能比较好的:"每一个模式描述了一个在我们周围不断重复发生的问题以及该问
题解决方案的核心.这样,你就能一次又一次地使用该方案而不必做重复劳动". 模式的核心就是特定
的解决方案,它有效而且足够的通用性,就解决重复出现的问题.模式的另一种视角是把它看做一组建
议,而创造模式的艺术则是将很多建议分解开,形成相互独立的组.在此基础上可以相对独立地讨论它
们.

模式的关键点是它们源于实践.必须观察人们的工作过程,发现其中好的设计,并找出"这些解决方案的
核心".这并不是一个简单的过程,但是一旦发现了某个模式,它将是非常又价值的.对于我来说,价值之
一是能够撰写这样一本参考书.你不必通读本书的全部内容,也不必通读所有关于模式的书.你只需要
了解到这些模式都是干什么的,它们解决什么问题,它们是如何解决问题的.就足够了.这样,一旦碰到
类似问题,就可以从书中找到相应的模式.

一旦需要使用模式,就必须知道如何将它运用于当前的问题.使用模式的关键之一是不能盲目使用,这
也是模式工具为什么都那么惨的原因.我认为模式是一种"半生不熟品",为了用好它,还必须在自己的
项目中把剩下的那一半"火候"补上.本人每次使用模式时,都会东改一点西改一点.因此你会多次看到
同一个解决方案,但没有一次是完全相同的.

每个模式相对独立,但又不彼此孤立.有时候它们相互影响,如影随形.例如,如果在设计中使用了领域
模型,那么经常还会用到类表继承.模式的边界本来也是模糊的,我在本书中也尽量让它们各自独立.如
果有人说"使用工作单元",你就可以直接去看工作单元这个模式如何使用,而不必阅读全书.

我们发现了某种模式,而不是发明了某种模式.如果和有经验的同事:直接叫术语;如果是新人:直接描
述.

#### 0.5.1 模式的结构
第一部分是模式的名字,模式名非常重要.如果了解这些模式,我告诉你Web服务器是用前端控制器和转
换视图构建的,而你又了解这些模式,那么你对我的Web服务器的架构就会非常清楚了.

接下来两部分是相关的:意图和概要.意图用一两句话总结模式;概要是模式的一种可视化表示,通常是
一个UML图.这主要是想给模式一个简单的概括,以帮助记忆.如果你对模式已经"心知肚明",只是不知
道它的名字,那么模式的意图和概要这两部分就能为你提供足够的信息.

模式的动机.  
1. "运行机制"部分描述了解决方案.会讨论一些实现问题以及遇到变化的情况.
2. "使用时机"部分描述了模式何时被使用.讨论促使我选择该模式而不是其他模式的权衡考虑.很多模
式都可以相互替代.因此,每当我选择一种模式之后,总是问自己"你什么时候能不用它?" 这个问题也
经常驱使我去选择其他方案.
3. "进一步阅读"部分给出了与该模式相关的其他读物.

为了尽量使例子简单但是又能够突出核心意思,主要选择那些简单而又明确的例子,而不是那些来自于
生成系统中的复杂例子.但是我们必须记住:过分强调具体应用环境反而会增加模式的复杂性,使得模式
的核心内容不易理解.

#### 0.5.2 模式的局限性
模式这个领域太大了,单凭一个人是无法面面俱到的.

当你使用模式时请记住:它们只是开始,而不是结束.任何作者去攘括项目开发中的所有变化和技术是不
可能的.我编写本书的目的只是作为一个开始,你们可以在此基础上继续努力.请大家记住:所有模式都
是不完备的,你们都有责任在自己的系统中完善它们,你们也会在这个过程中得到乐趣.












